class o{config;pendingRequests=new Map;pendingPings=new Map;messageListener;constructor(e={}){this.config={timeout:e.timeout??3e4,targetOrigin:e.targetOrigin??"*",source:e.source??"utags-webapp"},this.setupMessageListener()}async request(e){return new Promise((t,n)=>{const s=this.generateRequestId(),i=globalThis.setTimeout(()=>{this.pendingRequests.delete(s),n(new Error(`Request timeout after ${this.config.timeout}ms`))},this.config.timeout);this.pendingRequests.set(s,{resolve:t,reject:n,timeoutId:i});const r={type:"HTTP_REQUEST",source:this.config.source,id:s,payload:{method:e.method,url:e.url,headers:e.headers,body:e.body,timeout:e.timeout}};window.postMessage(r,this.config.targetOrigin)})}async isAvailable(){return new Promise(e=>{const t=this.generateRequestId(),s=globalThis.setTimeout(()=>{this.pendingPings.delete(t),e(!1)},1e3);this.pendingPings.set(t,{resolve(){clearTimeout(s),e(!0)},reject(){clearTimeout(s),e(!1)},timeoutId:s});const i={type:"PING",source:this.config.source,id:t};window.postMessage(i,this.config.targetOrigin)})}destroy(){this.messageListener&&(window.removeEventListener("message",this.messageListener),this.messageListener=void 0);for(const[e,t]of this.pendingRequests){clearTimeout(t.timeoutId);try{t.reject(new Error("HTTP client destroyed"))}catch{}}this.pendingRequests.clear();for(const[e,t]of this.pendingPings){clearTimeout(t.timeoutId);try{t.reject(new Error("HTTP client destroyed"))}catch{}}this.pendingPings.clear()}setupMessageListener(){this.messageListener||(this.messageListener=e=>{try{const t=e.data;if(!t||typeof t!="object"||!t.type||!t.id)return;switch(t.type){case"HTTP_RESPONSE":{this.handleHttpResponse(t);break}case"HTTP_ERROR":{this.handleHttpError(t);break}case"PONG":{this.handlePongMessage(t);break}}}catch(t){console.warn("Error handling message:",t)}},window.addEventListener("message",this.messageListener))}handleHttpResponse(e){const t=this.pendingRequests.get(e.id);if(t)if(this.pendingRequests.delete(e.id),clearTimeout(t.timeoutId),e.payload){const n=this.createHttpResponse(e.payload);t.resolve(n)}else t.reject(new Error("Invalid response payload"))}handleHttpError(e){const t=this.pendingRequests.get(e.id);if(!t)return;this.pendingRequests.delete(e.id),clearTimeout(t.timeoutId);const n=new Error(e.payload?.error||"HTTP request failed");e.payload?.details&&(n.details=e.payload.details),t.reject(n)}handlePongMessage(e){const t=this.pendingPings.get(e.id);t&&(this.pendingPings.delete(e.id),clearTimeout(t.timeoutId),t.resolve())}createHttpResponse(e){const t=new Headers;for(const[n,s]of Object.entries(e.headers))t.set(n,s);return{ok:e.ok,status:e.status,statusText:e.statusText,headers:t,text:async()=>e.body,json:async()=>JSON.parse(e.body),async arrayBuffer(){const s=new TextEncoder().encode(e.body),i=new ArrayBuffer(s.length);return new Uint8Array(i).set(s),i}}}generateRequestId(){return`http-req-${Date.now()}-${Math.random().toString(36).slice(2,11)}`}}const a=new o,c={async isMessageProxyAvailable(){return a.isAvailable()}};export{c as MessageProxyEnvironmentDetector,o as MessageProxyHttpClient,a as messageProxyHttpClient};
